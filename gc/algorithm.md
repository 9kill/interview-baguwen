# GC 算法
分析：算法可以从多个维度进行分析。

## 总览

### 两大步骤

首先，算法可以分成两个大问题
1. 如何找到存活对象：基本上就是两类，引用计数和标记；
2. 怎么回收空间：基本上也是两类，复制或者清扫；

这里要强调一下清扫。清扫明面上是指，我将垃圾扫掉，实际上是指将内存返回给内存分配器。那么问题就来了，内存分配器怎么维护这些空闲内存？基本上这里又是两种选择，一种是位图，一种是空闲链表法。相比之下，采用复制的算法，基本上就只需要维护寥寥几个地址。

而且不管哪种法子，都会造成内存分配碎片。例如我这里有一块4M的空闲内存块，分配出去了3.8M。后面的对象申请内存，都大于0.2M，那么我们就这一块内存永远也不会被分配出去。随着不断分配-回收，整个过程产生越来越多这种小的碎片，直到再也找不到任何一块足够大的内存来容纳新对象。

因此清扫的算法，通常伴随一个压缩的过程。所谓压缩，简单的实现是直接执行一次复制，将活着的对象直接复制到一块完整的内存。还有一种做法是挪动对象，填满这些碎片，腾出来的空间组成一块大的内存。

如果笛卡尔积一下，就有了：
1. 引用计数-复制，引用计数-清扫；
2. 标记-复制，标记-清扫；

考虑压缩，就还多一类，比如”标记-清扫-压缩”。

### 并发与并行

算法又有并发和并行之分。这里提到的并发和并行，在GC这个特定的语义下，含义稍微有点区别。

这里我们说的并发，其实是指 GC 线程和应用线程，一起运行。就是一边GC，一边对外服务。并行则是指多个GC线程一起干活。

那么，要记住，多核 CPU 之下，并发往往意味着并行。即，GC 线程和应用线程是并行的，GC线程和GC线程也是并行的，应用线程和应用线程也是并行的。

但是并行不一定意味着并发。例如 Java 里面的 Parallel New，就是GC线程并行收集，这个就不是并发的，因为没有应用线程此时也在运转。

### 分代

不是所有 GC 都有分代的！！

分代主要是基于分代假说，又分成强分代假说和弱分代假说。

强分代假说：
弱分代假说：

### 分区 or 分 Region

它有一点点类似分代的概念。但是它本质上就是把内存分成一块一块，然后尽量把回收范围局限在某些块内。例如典型的 G1 回收器，golang 的 span。

## 面试题

### 为什么要分代？
分析：其实分代不是最开始就有的，而是大家观察到了分代假说的两个现象之后，才有了分代的设计。那么分代究竟是为什么引入呢？很简单，就是既然新对象很容易就死掉，老对象很难死掉，那我们就分开着两个，然后新对象朝生夕死，这样就可以每次都回收大量的空间。而老对象待着的地方，我就可以少回收，反正也回收不到东西，只在确实没空间了我再回收。所以分代，核心就是为了提高 GC 效率。

回答这种问题，我们可以从如果不分代会有什么问题来引出，提高 GC 效率这么一个说法。但是还有一个难点，就是为啥有的 GC 实现是不分代的。